t4 <- t3 %>% select(sim, starts_with("x")) %>% arrange(sim) %>%
left_join(ttemp %>% arrange(sim), by = "sim") %>%
mutate(pickwinner = case_when(
nsuccess == 3 & x3<= x1 & x2 <= x1 ~ "Trt1",
nsuccess == 3 & x3<= x2 & x1 <= x2 ~ "Trt2",
nsuccess == 3 & x1<= x3 & x2 <= x3 ~ "Trt3",
nsuccess == 2 & x3<= x1 & x2 <= x1 ~ "Trt1",
nsuccess == 2 & x3<= x2 & x1 <= x2 ~ "Trt2",
nsuccess == 2 & x1<= x3 & x2 <= x3 ~ "Trt3",
nsuccess == 1 & x3<= x1 & x2 <= x1 ~ "Trt1",
nsuccess == 1 & x3<= x2 & x1 <= x2 ~ "Trt2",
nsuccess == 1 & x1<= x3 & x2 <= x3 ~ "Trt3",
nsuccess == 0 ~ "None"))
t4
case2 <- run_sim(nsim = 1e4, scenarios, row_id = "Case 2")
debug(run_sim)
case2 <- run_sim(nsim = 1e4, scenarios, row_id = "Case 2")
undebug(run_sim)
scenarios
ssessionInfo()
sessionInfo()
library(haven)
sessionInfo()
library(haven)
sessoinInfo()
sessionInfo()
rm(list = ls())
library(devtools)
library(roxygen2)
# devtools::use_testthat()
# devtools::use_data(CODES, internal = T)
setwd(paste(dirname(rstudioapi::getActiveDocumentContext()$path), "MethodDev", sep = "/"))
document()
check()
Sys.getenv("PATH")
#Sys.setenv(PATH = "C:/texlive/2016/bin/win32")
build(manual = T)
install.packages("../MethodDev_0.1.1.tar.gz", repos = NULL, type = "source")
library(MethodDev)
ia_pval(0.3)
ia_pval(0.5)
library(MethodDev)
ia_pval(0.3)
survival_test <- function(snapshot, pval_eff = 0.025, pval_fu = NA,
is_trt = NA){
arms <- sort(unique(snapshot$arm))
if (is.na(is_trt)){
# by default, arm = 2 shown in data is the treatment
is_trt <- arms[2]
}
is_control <- arms[arms != is_trt]
snapshot$arm <- factor(snapshot$arm, levels = c(is_control, is_trt))
# log-rank test p-value
surv <- survival::Surv(pfs, pfs_censor) ~ arm
lr <- survival::survdiff(surv, data = snapshot)  # run log-rank test
# chisq returns a two sided p value, so the p value should be halved
# lr_pvalue <- pchisq(lr$chisq, length(lr$n)-1, lower.tail = FALSE) / 2
z_lrt <- (lr$obs[1] - lr$exp[1]) / sqrt(lr$var[1,1])
lr_pvalue <- pnorm(-z_lrt)
# cox HR with 95% confidence interval
cox <- summary(survival::coxph(surv,data=snapshot))
hr <- cox$coefficients[,"exp(coef)"]
hr_conf <- c(cox$conf.int[,"lower .95"], cox$conf.int[,"upper .95"])
# median K-M survival
KM <- survival::survfit(surv, type="kaplan-meier",
conf.type="log", data=snapshot)
median_arms <- survminer::surv_median(KM)[,"median"]
median_diff <- median_arms[2] - median_arms[1]
# trial decision
if ( is.na(pval_fu)){
message("Runing interim analysis for efficacy only")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'interim/success'} else {
decision <- 'interim/continue'
}
} else if (is.na(pval_eff)) {
message("Running interim analysis for futility only")
if (lr_pvalue > pval_fu){
decision <- "interim/futility"
} else { decision <- "interim/continue"}
} else if (pval_eff < pval_fu){
message("running interim analysis for both efficacy and futility")
if (lr_pvalue < pval_eff & hr < 1){
decision <- "interim/success"
} else if (lr_pvalue >= pval_eff & lr_pvalue <= alpha_fu){
decision <- "interim/continue"
} else if (lr_pvalue > pval_fu) {
decision <- "interim/futility"
}
} else if (pval_eff == pval_fu){
message("Runing primary analysis")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'primary/success'} else{ decision <- 'primary/failure'
}
}
# subjects number
n <- sum(KM$n)
event_size <- sum(snapshot$pfs_censor == 1)
# output
return(tibble::tibble(n=n, pvalue=lr_pvalue, decision=decision,
event_size = event_size, hr=hr,
lower=hr_conf[1], upper=hr_conf[2],
median_ctr=median_arms[1], median_trt=median_arms[2],
median_diff=median_diff))
}
source('C:/Users/bzhuo/Box Sync/projects/method_development/build-package.R')
source('C:/Users/bzhuo/Box Sync/projects/method_development/build-package.R')
survival_test <- function(snapshot, pval_eff = 0.025, pval_fu = NA,
is_trt = NA){
arms <- sort(unique(snapshot$arm))
if (is.na(is_trt)){
# by default, arm = 2 shown in data is the treatment
is_trt <- arms[2]
}
is_control <- arms[arms != is_trt]
snapshot$arm <- factor(snapshot$arm, levels = c(is_control, is_trt))
# log-rank test p-value
surv <- survival::Surv(pfs, pfs_censor) ~ arm
lr <- survival::survdiff(surv, data = snapshot)  # run log-rank test
# chisq returns a two sided p value, so the p value should be halved
# lr_pvalue <- pchisq(lr$chisq, length(lr$n)-1, lower.tail = FALSE) / 2
z_lrt <- (lr$obs[1] - lr$exp[1]) / sqrt(lr$var[1,1])
lr_pvalue <- pnorm(-z_lrt)
# cox HR with 95% confidence interval
cox <- summary(survival::coxph(surv,data=snapshot))
hr <- cox$coefficients[,"exp(coef)"]
hr_conf <- c(cox$conf.int[,"lower .95"], cox$conf.int[,"upper .95"])
# median K-M survival
KM <- survival::survfit(surv, type="kaplan-meier",
conf.type="log", data=snapshot)
median_arms <- survminer::surv_median(KM)[,"median"]
median_diff <- median_arms[2] - median_arms[1]
# trial decision
if ( is.na(pval_fu)){
message("Runing interim analysis for efficacy only")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'interim/success'} else {
decision <- 'interim/continue'
}
} else if (is.na(pval_eff)) {
message("Running interim analysis for futility only")
if (lr_pvalue > pval_fu){
decision <- "interim/futility"
} else { decision <- "interim/continue"}
} else if (pval_eff < pval_fu){
message("running interim analysis for both efficacy and futility")
if (lr_pvalue < pval_eff & hr < 1){
decision <- "interim/success"
} else if (lr_pvalue >= pval_eff & lr_pvalue <= pval_fu){
decision <- "interim/continue"
} else if (lr_pvalue > pval_fu) {
decision <- "interim/futility"
}
} else if (pval_eff == pval_fu){
message("runing primary analysis")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'primary/success'} else{ decision <- 'primary/failure'
}
}
# subjects number
n <- sum(KM$n)
event_size <- sum(snapshot$pfs_censor == 1)
# output
return(tibble::tibble(n=n, pvalue=lr_pvalue, decision=decision,
event_size = event_size, hr=hr,
lower=hr_conf[1], upper=hr_conf[2],
median_ctr=median_arms[1], median_trt=median_arms[2],
median_diff=median_diff))
}
survival_test <- function(snapshot, pval_eff = 0.025, pval_fu = NA,
is_trt = NA){
arms <- sort(unique(snapshot$arm))
if (is.na(is_trt)){
# by default, arm = 2 shown in data is the treatment
is_trt <- arms[2]
}
is_control <- arms[arms != is_trt]
snapshot$arm <- factor(snapshot$arm, levels = c(is_control, is_trt))
# log-rank test p-value
surv <- survival::Surv(pfs, pfs_censor) ~ arm
lr <- survival::survdiff(surv, data = snapshot)  # run log-rank test
# chisq returns a two sided p value, so the p value should be halved
# lr_pvalue <- pchisq(lr$chisq, length(lr$n)-1, lower.tail = FALSE) / 2
z_lrt <- (lr$obs[1] - lr$exp[1]) / sqrt(lr$var[1,1])
lr_pvalue <- pnorm(-z_lrt)
# cox HR with 95% confidence interval
cox <- summary(survival::coxph(surv,data=snapshot))
hr <- cox$coefficients[,"exp(coef)"]
hr_conf <- c(cox$conf.int[,"lower .95"], cox$conf.int[,"upper .95"])
# median K-M survival
KM <- survival::survfit(surv, type="kaplan-meier",
conf.type="log", data=snapshot)
median_arms <- survminer::surv_median(KM)[,"median"]
median_diff <- median_arms[2] - median_arms[1]
# trial decision
if ( is.na(pval_fu)){
message("Runing interim analysis for efficacy only")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'interim/success'} else {
decision <- 'interim/continue'
}
} else if (is.na(pval_eff)) {
message("Running interim analysis for futility only")
if (lr_pvalue > pval_fu){
decision <- "interim/futility"
} else { decision <- "interim/continue"}
} else if (pval_eff < pval_fu){
message("running interim analysis for both efficacy and futility")
if (lr_pvalue < pval_eff & hr < 1){
decision <- "interim/success"
} else if (lr_pvalue >= pval_eff & lr_pvalue <= pval_fu){
decision <- "interim/continue"
} else if (lr_pvalue > pval_fu) {
decision <- "interim/futility"
}
} else if (pval_eff == pval_fu){
message("runing primary analysis")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'primary/success'} else{ decision <- 'primary/failure'
}
}
# subjects number
n <- sum(KM$n)
event_size <- sum(snapshot$pfs_censor == 1)
# output
return(tibble::tibble(n=n, pvalue=lr_pvalue, decision=decision,
event_size = event_size, hr=hr,
lower=hr_conf[1], upper=hr_conf[2],
median_ctr=median_arms[1], median_trt=median_arms[2],
median_diff=median_diff,
timecut = timecut))
}
rm(list = ls())
library(devtools)
library(roxygen2)
# devtools::use_testthat()
# devtools::use_data(CODES, internal = T)
setwd(paste(dirname(rstudioapi::getActiveDocumentContext()$path), "MethodDev", sep = "/"))
document()
check()
Sys.getenv("PATH")
#Sys.setenv(PATH = "C:/texlive/2016/bin/win32")
build(manual = T)
install.packages("../MethodDev_0.1.1.tar.gz", repos = NULL, type = "source")
library(AmgOnc)
news()
?news
?object.size
#' @param nsbj a vector specifying number of subjects to be randominzed for each
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
rand_arm <- function(nsbj, ratio){
n_b <- nsbj / ratio; n_block <- floor(min(n_b))
n_remainder <- nsbj - n_block*ratio
n_arm <- length(nsbj)
arm_name <- rep(paste("arm", 1:n_arm, sep = "_"), ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arm_name, sum(ratio), replace = F)))
}
# the remaining subjects are assigned, not randomized. It should be OK
arm_2 <- rep(paste("arm", 1:n_arm, sep = "_"), n_remainder)
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
rand_arm(nsbj = c(5, 8, 2), ratio = c(2, 2, 1))
rand_arm(nsbj = c(5, 8, 2), ratio = c(2, 3, 1))
xy <- rand_arm(nsbj = c(5, 8, 2), ratio = c(2, 3, 1))
xy
table(xy)
source('C:/Users/bzhuo/Box Sync/projects/method_development/build-package.R')
install.packages("../MethodDev_0.1.2.tar.gz", repos = NULL, type = "source")
library(MethodDev)
rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
rand_arm(nsbj = 10, ratio = 2)
rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
rand_arm(nsbj = c(10, 1), ratio = 2)
rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
rand_arm(nsbj = c(10, 2), ratio = 2)
rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
rand_arm(nsbj = c(10, 2), ratio = c(2, 1))
rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
rand_arm(nsbj = c(10, 2), ratio = c(2, 1))
rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
rand_arm(nsbj = c(10, 2), ratio = c(2, 1))
sample(1:5)
sample(1:5)
?sample
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio){
n_b <- nsbj / ratio; n_block <- floor(min(n_b))
n_remainder <- nsbj - n_block*ratio
n_arm <- length(nsbj)
arm_name <- rep(paste("arm", 1:n_arm, sep = "_"), ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arm_name, sum(ratio), replace = F)))
}
# the remaining subjects are assigned, not randomized. It should be OK
arm_2 <- rep(paste("arm", 1:n_arm, sep = "_"), n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(c(8, 7), c(3, 3))
rand_arm(c(8, 7), c(3, 3))
rand_arm(c(8, 7), c(3, 3))
rand_arm(c(8, 7), c(3, 3))
rand_arm(c(8, 7), c(3, 3))
rand_arm(c(8, 7), c(3, 3))
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio){
n_b <- nsbj / ratio;
n_block <- floor(min(n_b))
n_remainder <- nsbj - n_block*ratio
n_arm <- length(nsbj)
arm_name <- rep(paste("arm", 1:n_arm, sep = "_"), ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arm_name)))
}
arm_2 <- rep(paste("arm", 1:n_arm, sep = "_"), n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(c(0, 7), c(1, 1))
rand_arm(c(3, 7), c(1, 1))
rand_arm(c(3, 7), c(1, 0))
7/0
min(Inf, 3)
rand_arm(c(3, 7), c(2, 1))
rand_arm(c(3, 7), c(2, 1))
dat <- data.frame(x = rep(c("cat1", "cat2"), c(50, 100)), y = c(rexp(50), rnorm(100)))
View(dat)
library(ggplot2)
ggplot(data = dat, aes(x = y)) + geom_density(aes(color = x))
install.packages("checkpoint")
library(checkpoint)
source('C:/Users/bzhuo/Box Sync/projects/method_development/build-package.R')
source('C:/Users/bzhuo/Box Sync/projects/method_development/build-package.R')
survival_test <- function(snapshot, pval_eff = 0.025, pval_fu = NA,
is_trt = NA){
arms <- sort(unique(snapshot$arm))
if (is.na(is_trt)){
# by default, arm = 2 shown in data is the treatment
is_trt <- arms[2]
}
is_control <- arms[arms != is_trt]
snapshot$arm <- factor(snapshot$arm, levels = c(is_control, is_trt))
# log-rank test p-value
surv <- survival::Surv(pfs, pfs_censor) ~ arm
lr <- survival::survdiff(surv, data = snapshot)  # run log-rank test
# chisq returns a two sided p value, so the p value should be halved
# lr_pvalue <- pchisq(lr$chisq, length(lr$n)-1, lower.tail = FALSE) / 2
z_lrt <- (lr$obs[1] - lr$exp[1]) / sqrt(lr$var[1,1])
lr_pvalue <- pnorm(-z_lrt)
# cox HR with 95% confidence interval
cox <- summary(survival::coxph(surv,data=snapshot))
hr <- cox$coefficients[,"exp(coef)"]
hr_conf <- c(cox$conf.int[,"lower .95"], cox$conf.int[,"upper .95"])
# median K-M survival
KM <- survival::survfit(surv, type="kaplan-meier",
conf.type="log", data=snapshot)
median_arms <- survminer::surv_median(KM)[,"median"]
median_diff <- median_arms[2] - median_arms[1]
# trial decision
if ( is.na(pval_fu)){
#  message("Runing interim analysis for efficacy only")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'interim/success'} else {
decision <- 'interim/continue'
}
} else if (is.na(pval_eff)) {
#  message("Running interim analysis for futility only")
if (lr_pvalue > pval_fu){
decision <- "interim/futility"
} else { decision <- "interim/continue"}
} else if (pval_eff < pval_fu){
#  message("running interim analysis for both efficacy and futility")
if (lr_pvalue < pval_eff & hr < 1){
decision <- "interim/success"
} else if (lr_pvalue >= pval_eff & lr_pvalue <= pval_fu){
decision <- "interim/continue"
} else if (lr_pvalue > pval_fu) {
decision <- "interim/futility"
}
} else if (pval_eff == pval_fu){
#  message("runing primary analysis")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'primary/success'} else{ decision <- 'primary/failure'
}
}
# subjects number
n <- sum(KM$n)
event_size <- sum(snapshot$pfs_censor == 1)
if("timecut" %in% names(snapshot)){
timecut <- unique(snapshot$timecut)
} else{
timecut <- snapshot %>% filter(pfs_censor == 1) %>%
mutate(pfs_ca = pfs + timein) %>%
arrange(pfs_ca) %>% slice(n()) %>% pull(pfs_ca)
}
# output
return(tibble::tibble(n=n, pvalue=lr_pvalue, decision=decision,
event_size = event_size, hr=hr,
lower=hr_conf[1], upper=hr_conf[2],
median_ctr=median_arms[1], median_trt=median_arms[2],
median_diff=median_diff,
timecut = timecut))
}
library(gsDesign)
?gsDesign
gsDesign
#' @param beta the type 2 error, equal to \code{1 - power}
#' @param info_fraction the information fraction for each look, default set to
#'   be 1, meaning no interim analysis. Can take vector
#' @param ... other parameters inherited from \code{\link{[gsDesign]gsDesign}}
#' @import gsDesign
#' @return a tibble containing number of looks and efficacy/futility p values
#' @export
#' @examples
#' ia_pval(alpha = 0.025, beta = 0.1, info_fraction = c(0.5, 0.7))
#'
ia_pval <- function(info_fraction, alpha = 0.025, beta = 0.1,
sfu = sfLDOF, ...){
n_analysis <- length(info_fraction) + 1
timing <- c(info_fraction, 1)
## GS bound (Eff=O'brien-Fleming, FU=Gamma Family with parameter -4)
# get the efficacy boundary
bound_eff <- gsDesign::gsDesign(k = n_analysis, alpha = alpha,
timing = timing, sfu = sfu, ...)$upper
bound_eff_pval <- pnorm(-bound_eff$bound)
# get the futility boundary
bound_fu <- gsDesign::gsDesign(k = n_analysis, beta = beta,
timing = timing,  ...)$lower
bound_fu1 <- c(bound_fu$bound[1:n_analysis-1], bound_eff$bound[n_analysis])
bound_fu_pval <- pnorm(-bound_fu1)
cutoff <- tibble::tibble(look = 1:n_analysis, efficacy_bound = bound_eff_pval,
futility_bound = bound_fu_pval,
alpha = alpha, power = 1 - beta)
return(cutoff)
}
ia_pval(0.75)
rm(list = ls())
library(devtools)
library(roxygen2)
# devtools::use_testthat()
# devtools::use_data(CODES, internal = T)
setwd(paste(dirname(rstudioapi::getActiveDocumentContext()$path), "MethodDev", sep = "/"))
document()
check()
Sys.getenv("PATH")
#Sys.setenv(PATH = "C:/texlive/2016/bin/win32")
build(manual = T)
install.packages("../MethodDev_0.1.2.tar.gz", repos = NULL, type = "source")
library(MethodDev)
ia_pval(0.7)
ia_pval(0.75)
install.packages("../MethodDev_0.1.1.tar.gz", repos = NULL, type = "source")
library(MethodDev)
ia_pval()
ia_pval
ia_pval(0.7)
ia_pval(0.75)
library(MethodDev)
ia_pval(0.75)
ia_pval
rm(list = ls())
library(devtools)
library(roxygen2)
# devtools::use_testthat()
# devtools::use_data(CODES, internal = T)
setwd(paste(dirname(rstudioapi::getActiveDocumentContext()$path), "MethodDev", sep = "/"))
document()
check()
Sys.getenv("PATH")
#Sys.setenv(PATH = "C:/texlive/2016/bin/win32")
build(manual = T)
install.packages("../MethodDev_0.1.2.tar.gz", repos = NULL, type = "source")
