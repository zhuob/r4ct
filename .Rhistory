n_block <- floor(min(n_b))
n_remainder <- nsbj - n_block*ratio
n_arm <- length(nsbj)
arm_name <- rep(paste("arm", 1:n_arm, sep = "_"), ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arm_name)))
}
arm_2 <- rep(paste("arm", 1:n_arm, sep = "_"), n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(c(0, 7), c(1, 1))
rand_arm(c(3, 7), c(1, 1))
rand_arm(c(3, 7), c(1, 0))
7/0
min(Inf, 3)
rand_arm(c(3, 7), c(2, 1))
rand_arm(c(3, 7), c(2, 1))
dat <- data.frame(x = rep(c("cat1", "cat2"), c(50, 100)), y = c(rexp(50), rnorm(100)))
View(dat)
library(ggplot2)
ggplot(data = dat, aes(x = y)) + geom_density(aes(color = x))
install.packages("checkpoint")
library(checkpoint)
source('C:/Users/bzhuo/Box Sync/projects/method_development/build-package.R')
source('C:/Users/bzhuo/Box Sync/projects/method_development/build-package.R')
survival_test <- function(snapshot, pval_eff = 0.025, pval_fu = NA,
is_trt = NA){
arms <- sort(unique(snapshot$arm))
if (is.na(is_trt)){
# by default, arm = 2 shown in data is the treatment
is_trt <- arms[2]
}
is_control <- arms[arms != is_trt]
snapshot$arm <- factor(snapshot$arm, levels = c(is_control, is_trt))
# log-rank test p-value
surv <- survival::Surv(pfs, pfs_censor) ~ arm
lr <- survival::survdiff(surv, data = snapshot)  # run log-rank test
# chisq returns a two sided p value, so the p value should be halved
# lr_pvalue <- pchisq(lr$chisq, length(lr$n)-1, lower.tail = FALSE) / 2
z_lrt <- (lr$obs[1] - lr$exp[1]) / sqrt(lr$var[1,1])
lr_pvalue <- pnorm(-z_lrt)
# cox HR with 95% confidence interval
cox <- summary(survival::coxph(surv,data=snapshot))
hr <- cox$coefficients[,"exp(coef)"]
hr_conf <- c(cox$conf.int[,"lower .95"], cox$conf.int[,"upper .95"])
# median K-M survival
KM <- survival::survfit(surv, type="kaplan-meier",
conf.type="log", data=snapshot)
median_arms <- survminer::surv_median(KM)[,"median"]
median_diff <- median_arms[2] - median_arms[1]
# trial decision
if ( is.na(pval_fu)){
#  message("Runing interim analysis for efficacy only")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'interim/success'} else {
decision <- 'interim/continue'
}
} else if (is.na(pval_eff)) {
#  message("Running interim analysis for futility only")
if (lr_pvalue > pval_fu){
decision <- "interim/futility"
} else { decision <- "interim/continue"}
} else if (pval_eff < pval_fu){
#  message("running interim analysis for both efficacy and futility")
if (lr_pvalue < pval_eff & hr < 1){
decision <- "interim/success"
} else if (lr_pvalue >= pval_eff & lr_pvalue <= pval_fu){
decision <- "interim/continue"
} else if (lr_pvalue > pval_fu) {
decision <- "interim/futility"
}
} else if (pval_eff == pval_fu){
#  message("runing primary analysis")
if (lr_pvalue < pval_eff & hr < 1) {
decision <- 'primary/success'} else{ decision <- 'primary/failure'
}
}
# subjects number
n <- sum(KM$n)
event_size <- sum(snapshot$pfs_censor == 1)
if("timecut" %in% names(snapshot)){
timecut <- unique(snapshot$timecut)
} else{
timecut <- snapshot %>% filter(pfs_censor == 1) %>%
mutate(pfs_ca = pfs + timein) %>%
arrange(pfs_ca) %>% slice(n()) %>% pull(pfs_ca)
}
# output
return(tibble::tibble(n=n, pvalue=lr_pvalue, decision=decision,
event_size = event_size, hr=hr,
lower=hr_conf[1], upper=hr_conf[2],
median_ctr=median_arms[1], median_trt=median_arms[2],
median_diff=median_diff,
timecut = timecut))
}
library(gsDesign)
?gsDesign
gsDesign
#' @param beta the type 2 error, equal to \code{1 - power}
#' @param info_fraction the information fraction for each look, default set to
#'   be 1, meaning no interim analysis. Can take vector
#' @param ... other parameters inherited from \code{\link{[gsDesign]gsDesign}}
#' @import gsDesign
#' @return a tibble containing number of looks and efficacy/futility p values
#' @export
#' @examples
#' ia_pval(alpha = 0.025, beta = 0.1, info_fraction = c(0.5, 0.7))
#'
ia_pval <- function(info_fraction, alpha = 0.025, beta = 0.1,
sfu = sfLDOF, ...){
n_analysis <- length(info_fraction) + 1
timing <- c(info_fraction, 1)
## GS bound (Eff=O'brien-Fleming, FU=Gamma Family with parameter -4)
# get the efficacy boundary
bound_eff <- gsDesign::gsDesign(k = n_analysis, alpha = alpha,
timing = timing, sfu = sfu, ...)$upper
bound_eff_pval <- pnorm(-bound_eff$bound)
# get the futility boundary
bound_fu <- gsDesign::gsDesign(k = n_analysis, beta = beta,
timing = timing,  ...)$lower
bound_fu1 <- c(bound_fu$bound[1:n_analysis-1], bound_eff$bound[n_analysis])
bound_fu_pval <- pnorm(-bound_fu1)
cutoff <- tibble::tibble(look = 1:n_analysis, efficacy_bound = bound_eff_pval,
futility_bound = bound_fu_pval,
alpha = alpha, power = 1 - beta)
return(cutoff)
}
ia_pval(0.75)
rm(list = ls())
library(devtools)
library(roxygen2)
# devtools::use_testthat()
# devtools::use_data(CODES, internal = T)
setwd(paste(dirname(rstudioapi::getActiveDocumentContext()$path), "MethodDev", sep = "/"))
document()
check()
Sys.getenv("PATH")
#Sys.setenv(PATH = "C:/texlive/2016/bin/win32")
build(manual = T)
install.packages("../MethodDev_0.1.2.tar.gz", repos = NULL, type = "source")
library(MethodDev)
ia_pval(0.7)
ia_pval(0.75)
install.packages("../MethodDev_0.1.1.tar.gz", repos = NULL, type = "source")
library(MethodDev)
ia_pval()
ia_pval
ia_pval(0.7)
ia_pval(0.75)
library(MethodDev)
ia_pval(0.75)
ia_pval
rm(list = ls())
library(devtools)
library(roxygen2)
# devtools::use_testthat()
# devtools::use_data(CODES, internal = T)
setwd(paste(dirname(rstudioapi::getActiveDocumentContext()$path), "MethodDev", sep = "/"))
document()
check()
Sys.getenv("PATH")
#Sys.setenv(PATH = "C:/texlive/2016/bin/win32")
build(manual = T)
install.packages("../MethodDev_0.1.2.tar.gz", repos = NULL, type = "source")
asin(3)
asin(0.2)
asin(0.5)
pi/4
pi/6
rm(list = ls())
library(devtools)
library(roxygen2)
# devtools::use_testthat()
# devtools::use_data(CODES, internal = T)
setwd(paste(dirname(rstudioapi::getActiveDocumentContext()$path), "MethodDev", sep = "/"))
document()
check()
Sys.getenv("PATH")
#Sys.setenv(PATH = "C:/texlive/2016/bin/win32")
build(manual = T)
install.packages("../MethodDev_0.1.2.tar.gz", repos = NULL, type = "source")
remove.packages("gsDesign", lib="~/R/R-3.5.1/library")
remove.packages("MethodDev", lib="~/R/R-3.5.1/library")
remove.packages("MethodDev", lib="~/R/win-library/3.5")
library(gsDesign)
install.packages("../MethodDev_0.1.2.tar.gz", repos = NULL, type = "source")
?install.packages
install.packages("gsDesign", lib="C:/Users/bzhuo/Documents/R/R-3.5.1/library")
install.packages("../MethodDev_0.1.2.tar.gz")
remove.packages("gsDesign", lib="~/R/R-3.5.1/library")
install.packages("../MethodDev_0.1.2.tar.gz", dependencies = "Imports")
install.packages("C:/Users/bzhuo/Box Sync/projects/method_development/MethodDev_0.1.2.tar.gz", repos = NULL, type = "source", lib="C:/Users/bzhuo/Documents/R/R-3.5.1/library")
?build
install.packages("../MethodDev_0.1.2.tar.gz", dependencies = TRUE)
devtools::install_local("../MethodDev_0.1.2.tar.gz")
remove.packages("Rdpack", lib="~/R/R-3.5.1/library")
install.packages("gsDesign", lib="C:/Users/bzhuo/Documents/R/R-3.5.1/library")
devtools::install_local("../MethodDev_0.1.2.tar.gz", dependencies = NA,
upgrade = "ask")
?install.packages
remove.packages("Rdpack", lib="~/R/win-library/3.5")
remove.packages("MethodDev", lib="~/R/win-library/3.5")
install.packages("../MethodDev_0.1.2.tar.gz", type = "source", dependencies = "Imports")
# install.packages("../MethodDev_0.1.2.tar.gz", type = "source", dependencies = "Imports")
devtools::install_local("../MethodDev_0.1.2.tar.gz", dependencies = NA,
upgrade = "ask")
MethodDev::rand_arm(c(5,4), ratio = c(1,1))
MethodDev::rand_arm(9, ratio = c(1,1))
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio, arm_name = paste("arm", 1:length(nsbj), sep = "_")){
n_by_arm <- floor(nsbj / sum(ratio))
n_per_arm <- rep(n_by_arm, lenght(ratio))
n_b <- n_per_arm / ratio
n_block <- floor(min(n_b))
n_remainder <- nsbj - sum(n_per_arm)
n_arm <- length(nsbj)
arms <- rep(arm_name, ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arms)))
}
arm_2 <- rep(arm_name, n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(9, c(1, 1))
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio, arm_name = paste("arm", 1:length(nsbj), sep = "_")){
n_by_arm <- floor(nsbj / sum(ratio))
n_per_arm <- rep(n_by_arm, length(ratio))
n_b <- n_per_arm / ratio
n_block <- floor(min(n_b))
n_remainder <- nsbj - sum(n_per_arm)
n_arm <- length(nsbj)
arms <- rep(arm_name, ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arms)))
}
arm_2 <- rep(arm_name, n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(9, c(1, 1))
debug(rand_arm)
rand_arm(9, c(1, 1))
n_by_arm
n_per_arm
n_b
n_remainder
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio, arm_name = paste("arm", 1:length(nsbj), sep = "_")){
n_arm <- length(ratio)
n_block <- floor(nsbj / sum(ratio))
n_per_arm <- rep(n_by_arm, n_arm)
n_remainder <- nsbj - sum(n_per_arm)
arms <- rep(arm_name, ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arms)))
}
arm_2 <- rep(arm_name, n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(9, c(1, 1))
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio, arm_name = paste("arm", 1:length(nsbj), sep = "_")){
n_arm <- length(ratio)
n_block <- floor(nsbj / sum(ratio))
n_per_arm <- rep(block, n_arm)
n_remainder <- nsbj - sum(n_per_arm)
arms <- rep(arm_name, ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arms)))
}
arm_2 <- rep(arm_name, n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(9, c(1, 1))
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio, arm_name = paste("arm", 1:length(nsbj), sep = "_")){
n_arm <- length(ratio)
n_block <- floor(nsbj / sum(ratio))
n_per_arm <- rep(n_block, n_arm)
n_remainder <- nsbj - sum(n_per_arm)
arms <- rep(arm_name, ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arms)))
}
arm_2 <- rep(arm_name, n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(9, c(1, 1))
debug(rand_arm)
rand_arm(9, c(1, 1))
rand_arm(9, c(1, 1))
arm_name
ratio
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio, arm_name = paste("arm", 1:length(ratio), sep = "_")){
n_arm <- length(ratio)
n_block <- floor(nsbj / sum(ratio))
n_per_arm <- rep(n_block, n_arm)
n_remainder <- nsbj - sum(n_per_arm)
arms <- rep(arm_name, ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arms)))
}
arm_2 <- rep(arm_name, n_remainder)
arm_2 <- sample(arm_2) ## shuffle it
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(9, c(1, 1))
debug(rand_arm)
rand_arm(9, c(1, 1))
arms
n_remainder
arm_2
arm_name
n_remainder
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio, arm_name = paste("arm", 1:length(ratio), sep = "_")){
n_arm <- length(ratio)
n_block <- floor(nsbj / sum(ratio))
n_per_arm <- rep(n_block, n_arm)
n_remainder <- nsbj - sum(n_per_arm)
arms <- rep(arm_name, ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arms)))
}
arm_2 <- sample(arm_name, n_remainder)
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(9, c(1, 1))
table(rand_arm(9, c(1, 1)))
table(rand_arm(9, c(1, 1)))
table(rand_arm(9, c(1, 1)))
table(rand_arm(9, c(1, 1)))
table(rand_arm(9, c(1, 1)))
table(rand_arm(1, c(1, 1)))
table(rand_arm(1, c(1, 1)))
table(rand_arm(1, c(1, 1)))
table(rand_arm(1, c(1, 1)))
table(rand_arm(1, c(1, 1)))
table(rand_arm(1, c(1, 1)))
table(rand_arm(1, c(1, 1)))
table(rand_arm(1, c(1, 1)))
table(rand_arm(12, c(2, 2, 1)))
rand_arm(12, c(2, 2, 1))
debug(rand_arm)
rand_arm(12, c(2, 2, 1))
n_remainder
n_arm
n_block
n_per_arm
arm_1
length(arm_1)
rand_arm(12, c(2, 2, 1))
arm_name
n_remainder
nsbj
n_per_arm
n_per_arm
ratio
n_per_arm*ratio
#'   arm
#' @param ratio the allocation ratio
#'
#' @return a vector of length `sum(nsbj)` with randomized treatment arms
#' @export
#'
#' @examples
#' rand_arm(nsbj = c(0, 1), ratio = c(1, 1))
#' rand_arm(nsbj = c(5, 5, 2), ratio = c(2, 2, 1))
#'
rand_arm <- function(nsbj, ratio, arm_name = paste("arm", 1:length(ratio), sep = "_")){
n_arm <- length(ratio)
n_block <- floor(nsbj / sum(ratio))
n_per_arm <- rep(n_block, n_arm)
n_remainder <- nsbj - sum(n_per_arm * ratio)
arms <- rep(arm_name, ratio)
if(n_block == 0){
arm_1 <- NULL
} else{
arm_1 <- as.vector(replicate(n_block, sample(arms)))
}
arm_2 <- sample(arm_name, n_remainder)
arm <- c(arm_1, arm_2)
return(arm)
}
rand_arm(12, c(2, 2, 1))
rand_arm(12, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(1, c(2, 2, 1))
rand_arm(nsbj = 12, ratio = c(2, 2, 1))
rand_arm(nsbj = 12, ratio = c(5, 5, 2))
table(rand_arm(nsbj = 12, ratio = c(5, 5, 2)))
table(rand_arm(nsbj = 24, ratio = c(5, 5, 2)))
table(rand_arm(nsbj = 48, ratio = c(5, 5, 2)))
table(rand_arm(nsbj = 48, ratio = c(5, 5, 2)))
table(rand_arm(nsbj = 48, ratio = c(5, 5, 2)))
table(rand_arm(nsbj = 48, ratio = c(5, 5, 2)))
rm(list = ls())
library(devtools)
library(roxygen2)
# devtools::use_testthat()
# devtools::use_data(CODES, internal = T)
setwd(paste(dirname(rstudioapi::getActiveDocumentContext()$path), "MethodDev", sep = "/"))
document()
check()
Sys.getenv("PATH")
#Sys.setenv(PATH = "C:/texlive/2016/bin/win32")
build(manual = T)
# install.packages("../MethodDev_0.1.2.tar.gz", type = "source", dependencies = "Imports")
devtools::install_local("../MethodDev_0.1.2.tar.gz", dependencies = NA,
upgrade = "ask")
