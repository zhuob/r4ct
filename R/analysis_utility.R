
#' calculate the bivariate normal probabilities for a given h,k and rho
#'
#' @title upper tail probability of a standard binormal distribution
#' @details This function calculates the following quantity, \deqn{L(h, k, \rho)
#'   =\frac{1}{\sqrt{1-\rho^2}}\int_h^{\infty}\int_k^{\infty}e^{-\frac{x^2-2\rho
#'   xy + y^2}{2(1-\rho^2)}}dxdy} using formula Eq.(3) in the reference.

#' @param h the cutoff value for x; will integrate from `h` to `Inf`
#' @param k the cutoff value for y; will integrate from `k` to `Inf`
#' @param rho the correlation of the bivariate normal distribution.
#' @import Rdpack
#' @return a p value
#' @export
#' @references{
#'   \insertRef{genz2004numerical}{MethodDev}
#' }
#'  \url{https://link.springer.com/content/pdf/10.1023/B:STCO.0000035304.20635.31.pdf}
#'
#' @importFrom Rdpack reprompt

bvn_prob <- function(h, k, rho){

  bvn_dens <- function(x, y, theta){
    1/(2*pi)*exp(-(x^2 + y^2 - 2*x*y*sin(theta))/(2* ( cos(theta))^2 ) )
  }

 p1 <- pnorm(-h)*pnorm(-k)
 p2 <- integrate(bvn_dens, lower = 0, upper = asin(rho), x = h, y = k)$value
 result <- p1 + p2
 return(result)
}

#' final analysis for Cong's method
#'
#' @param snapshot the data snapshot
#' @param marker_positive  the label for biomarker positive population
#' @param alpha1 significance level for testing all-comers population
#' @param alpha2 significance level for testing biomarker positive population
#' @return a tibble summarizing the analysis results
#' @export
#' @examples

cong_final_analysis <- function(snapshot, marker_positive = "DLL3+",
                        alpha1 = 0.0125, alpha2 = 0.0125){

  # if there is enrichment, then there are two populations: all-comers and enrichment
  n_population <- length(unique(snapshot$population))

  enrichment <- n_population == 2

  if(enrichment){
    # if there is enrichment, then test all comers,
    # and Positive in all-comers + enrichment Positives
    marker_p <- snapshot %>% filter(marker == marker_positive)
    all_comer <- snapshot %>% filter(population == "all comers")
  } else{
    # if there is no enrichment, then test all comers,
    # and Positive in all-comers
    marker_p <- snapshot %>% filter(marker == marker_positive)
    all_comer <- snapshot
  }

  all_comer_result <- run_test(snapshot = all_comer, alpha_eff = alpha1,
                               alpha_fu = alpha1) %>%
                       mutate(population = "all comers")

  marker_p_result <- run_test(snapshot = marker_p, alpha_eff = alpha2,
                              alpha_fu = alpha2) %>%
                       mutate(population = marker_positive)

  rslt <- bind_rows(all_comer_result, marker_p_result)

  return(rslt)
}




## first: test biomarker negative populations
# other parameters are inherit from take_snapshot
#' @title Enrichment decision making
#' @details This function performs analysis for the biomarker negative
#'   population, then decides if enrichment is needed
#'
#' @param cong_dat a data set generated by \code{\link{cong_dat_gen}}
#' @param marker_negative a string specifying which marker is negative
#' @param endpoint the endpoint used to calculate the decision rule
#' @param sbj number of subjects to be included in analysis of biomarker negative
#' @param fu_time_ia minimum follow-up time for eligible evaluation
#' @param cutoff the cutoff chosen to make the decision
#' @return a tibble with decision included (see column \code{need_enrichment})
#' @export
#'
test_bm_neg <- function(cong_dat, marker_negative = "DLL3-",
                        endpoint = "resp", sbj = 100, fu_time_ia = 2,
                        cutoff = 0){

  # find the time of enrollment for sbj
  timein_cut <- cong_dat %>% arrange(timein) %>% slice(sbj) %>% pull(timein)
  # make sure that subjects being evaluated have been followed up enough time
  time_cut <- timein_cut - fu_time_ia
  snapshot <- cong_dat %>% filter(timein <= time_cut)

  # choose the marker negative population and subject number at cut time
  snapshot_bm_neg <- snapshot %>% filter(marker == marker_negative)

  if (endpoint == "resp"){
    # decision process
    orr <- snapshot_bm_neg %>% group_by(arm) %>% summarize(orr = mean(resp))
    ptrt <- orr %>% filter(arm == 2) %>% pull(orr)
    pctrl <- orr %>% filter(arm == 1) %>% pull(orr)

    if (ptrt - pctrl < cutoff) {
      need_enrichment <- "YES"
    } else{ need_enrichment  <- "NO"}
    result <- tibble::tibble(endpoint = endpoint, size_trt = ptrt,
                             size_ctrl = pctrl, cutoff = cutoff,
                             cut_time_ca = timein_cut,
                             need_enrichment = need_enrichment)

  } else if (endpoint == "pfs"){
    # decision process

    result <- tibble::tibble(endpoint = endpoint, size_trt = ptrt,
                             size_ctrl = pctrl,  cutoff = cutoff,
                             cut_time_ca = timein_cut,
                             need_enrichment = need_enrichment)
  }

  # return decision result
  return(result)
}



#' Decide interim analysis cutoff value for group sequential design
#'
#' @param alpha the desired type 1 error
#' @param beta the type 2 error, equal to \code{1 - power}
#' @param info_fraction the information fraction for each look, default set to
#'   be 1, meaning no interim analysis. Can take vector
#' @param ... other parameters inherited from \code{\link{[gsDesign]gsDesign}}
#' @import gsDesign
#' @return a tibble containing number of looks and efficacy/futility p values
#' @export
#' @examples
#' ia_pval(alpha = 0.025, beta = 0.1, info_fraction = c(0.5, 0.7))
#'
ia_pval <- function(info_fraction, alpha = 0.025, beta = 0.1, ...){
#  function (info_fraction, alpha = 0.025, beta = 0.1, sfu = sfLDOF, ...)

   n_analysis <- length(info_fraction) + 1
  timing <- c(info_fraction, 1)


  ## GS bound (Eff=O'brien-Fleming, FU=Gamma Family with parameter -4)
  # get the efficacy boundary

  bound_eff <- gsDesign::gsDesign(k = n_analysis, alpha = alpha,
                                  timing = timing, sfu = sfLDOF, ...)$upper
  bound_eff_pval <- pnorm(-bound_eff$bound)

  # bound_eff <- gsDesign::gsDesign(k = n_analysis, alpha = alpha,
  #                                 timing = timing, sfu = sfu, ...)$upper
  # bound_eff_pval <- pnorm(-bound_eff$bound)

  # get the futility boundary
  bound_fu <- gsDesign::gsDesign(k = n_analysis, timing = timing,
                                 test.type = 4, beta = beta, sflpar = -4, ...)$lower
  # bound_fu <- gsDesign::gsDesign(k = n_analysis, beta = beta,
  #                                timing = timing,  ...)$lower
  bound_fu1 <- c(bound_fu$bound[1:n_analysis-1], bound_eff$bound[n_analysis])
  bound_fu_pval <- pnorm(-bound_fu1)

  cutoff <- tibble::tibble(look = 1:n_analysis, efficacy_bound = bound_eff_pval,
                           futility_bound = bound_fu_pval,
                           alpha = alpha, power = 1 - beta)
  return(cutoff)
}


