test_that("test decision table generated by mTPI method", {
  

  #
  ex_dtab1 <- matrix(NA, ncol = 10, nrow = 11)
  ex_dtab1[1:2,   1] <- c("E", "D")
  ex_dtab1[1:3,   2] <- c("E", "S", "D")
  ex_dtab1[1:4,   3] <- c("E", "S", "D", "DU")
  ex_dtab1[1:5,   4] <- c("E", "S", "S", "DU", "DU")
  ex_dtab1[1:6,   5] <- c("E", "S", "S", "D",  "DU", "DU")
  ex_dtab1[1:7,   6] <- c("E", "E", "S", "S",  "DU", "DU", "DU")
  ex_dtab1[1:8,   7] <- c("E", "E", "S", "S",  "D",  "DU", "DU", "DU")
  ex_dtab1[1:9,   8] <- c("E", "E", "S", "S",  "D",  "DU", "DU", "DU", "DU")
  ex_dtab1[1:10,  9] <- c("E", "E", "S", "S",  "S",  "DU", "DU", "DU", "DU", "DU")
  ex_dtab1[1:11, 10] <- c("E", "E", "S", "S",  "S",  "D",  "DU", "DU", "DU", "DU", "DU")
  colnames(ex_dtab1) <- paste("n=", 1:ncol(ex_dtab1), sep = "")
  row.names(ex_dtab1) <- paste("dlt=", 1:nrow(ex_dtab1)-1, sep = "")
  
  x1 <- mtpi2_decision_matrix(cocap = 10, target = 0.3, a = 1, b = 1, tolerance1 = 0.05, tolerance2 = 0.05, tox = 0.95, method = "mtpi")
  expect_equal(x1, ex_dtab1)
  
  
  # example in the table using mTPI2 method from the mTPI2 paper
  ex_dtab <- matrix(NA, ncol = 10, nrow = 11)
  ex_dtab[1:2,   1] <- c("E", "D")
  ex_dtab[1:3,   2] <- c("E", "D", "D")
  ex_dtab[1:4,   3] <- c("E", "S", "D", "DU")
  ex_dtab[1:5,   4] <- c("E", "S", "D", "DU", "DU")
  ex_dtab[1:6,   5] <- c("E", "E", "D", "D",  "DU", "DU")
  ex_dtab[1:7,   6] <- c("E", "E", "S", "D",  "DU", "DU", "DU")
  ex_dtab[1:8,   7] <- c("E", "E", "S", "D",  "D",  "DU", "DU", "DU")
  ex_dtab[1:9,   8] <- c("E", "E", "S", "D",  "D",  "DU", "DU", "DU", "DU")
  ex_dtab[1:10,  9] <- c("E", "E", "E", "S",  "D",  "DU", "DU", "DU", "DU", "DU")
  ex_dtab[1:11, 10] <- c("E", "E", "E", "S",  "D",  "D",  "DU", "DU", "DU", "DU", "DU")
  colnames(ex_dtab) <- paste("n=", 1:ncol(ex_dtab), sep = "")
  row.names(ex_dtab) <- paste("dlt=", 1:nrow(ex_dtab)-1, sep = "")
  
  
  x2 <- mtpi2_decision_matrix(cocap = 10, target = 0.3, a = 1, b = 1, tolerance1 = 0.05, tolerance2 = 0.05, tox = 0.95, method = "mtpi2")
  expect_equal(x2, ex_dtab)
  
  
  # understanding the algorithm: The folloiwng code demonstrate the example in
  # the paper, when you see 3 out of 6 subjects having DLT, mTPI says "S" while
  # mTPI2 says "D"
  # x <- 3; n <- 6;
  # a <- 1; b <- 1; # prior
  # # posterior parameters
  # pos_a <- a + x; pos_b <- n - x + b; c(pos_a, pos_b)
  # tolerance1 <- 0.05; tolerance2 <- 0.05; target <- 0.3
  # pt1 <- target - tolerance1; pt2 <- target + tolerance2
  # 
  # # under mTPI1
  # intv <- c(0, pt1, pt2, 1)
  # intv_l <- diff(intv)
  # sr1 <- pbeta(intv[-1], shape1 = pos_a, shape2 = pos_b) - pbeta(intv[1:(length(intv)-1)], shape1 = pos_a, shape2 = pos_b)
  # upm <- sr1 /intv_l # probability divided by interval length
  # 
  # # for mTPI2, the intervals are further divided so each interval (except head and tail) have equal length
  # intv2 <- c(0, seq(0.05, 0.95, by = 0.1), 1)
  # 
  # sr2 <- pbeta(intv2[-1], shape1 = 4, shape2 = 4) - pbeta(intv2[1:11], shape1 = 4, shape2 = 4)
  # upm2 <- sr2/diff(intv2)
  # which.max(upm2); cut(intv2, breaks = c(-1, pt1, pt2, 1))
  # 
  
})




test_that("test decision table generated by BOIN method", {
  
  ## the functions from BOIN R package
  boin_decision <- function(target_tox, cohort_cap, ...){
    library(magrittr)
    # 100*3 subjects should generate a large enough decision matrix to cover all situation in real practice
    bound <- BOIN::get.boundary(target = target_tox, ncohort = 100, 
                                cohortsize = 3, ...) 
    
    temp2 <- bound$full_boundary_tab %>% tibble::as_tibble() %>% 
      dplyr::mutate(type = c("nsbj", "E", "D", "DU")) %>%
      tidyr::pivot_longer(cols = 1:100, names_to = "nsbj", values_to = "DLT") %>% 
      dplyr::mutate(nsbj = as.numeric(stringr::str_extract(nsbj, "(\\d)+"))) %>%
      dplyr::filter(type != "nsbj") %>% dplyr::arrange(nsbj, DLT)
    temp2 <- temp2[complete.cases(temp2), ]
    
    nsbj0 <- min(max(temp2$nsbj), cohort_cap)
    temp3 <- purrr::map_df(1:nsbj0, .f = function(i) 
      dplyr::bind_rows(tibble::tibble(nsbj = i, DLT = 0:i)))
    
    temp4 <- dplyr::right_join(temp2 %>% dplyr::arrange(nsbj, DLT), temp3, by = c("nsbj", "DLT"))
    temp5 <- temp2 %>% dplyr::filter(nsbj <= nsbj0)%>% 
      tidyr::pivot_wider(names_from = "type", values_from = "DLT", id_cols = "nsbj") #spread(key = type, value = DLT)
    temp6 <- dplyr::left_join(temp5, temp3, by = "nsbj") %>% 
      dplyr::mutate(decision = dplyr::case_when(
        DLT <= E ~ "E",
        E < DLT & DLT < D ~ "S",
        DLT >= D & (DLT < DU | is.na(DU)) ~ "D", 
        DLT >= DU ~ "DU"
      ))
    
    t7 <- temp6 %>% dplyr::select(nsbj, DLT, decision) %>% 
      #  spread(key = nsbj, value = decision)
      tidyr::pivot_wider(id_cols = "DLT", names_from = "nsbj", values_from = "decision")
    
    dmat <- as.matrix(t7[, -1])
    
    row.names(dmat) <- paste("dlt=", 1:nrow(dmat)-1, sep = "")
    colnames(dmat) <- paste("n=", 1:ncol(dmat), sep = "")
    
    return(dmat)
  }
  
  # test equality of table in S1 of the paper
  target1 <- 0.20
  x1 <- boin_decision(target_tox = target1, cohort_cap = 18)
  x2 <- boin_decision_matrix(18, target1)
  expect_equal(x1, x2)
  
  target1 <- 0.25
  x3 <- boin_decision(target_tox = target1, cohort_cap = 18)
  x4 <- boin_decision_matrix(18, target1)
  expect_equal(x3, x4)
  
  
  }
)